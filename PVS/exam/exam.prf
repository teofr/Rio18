(exam
 (duplicate_elements_TCC1 0
  (duplicate_elements_TCC1-1 nil 3728454584
   ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil))
   nil))
 (cons_append 0
  (cons_append-1 nil 3728454585
   ("" (skeep)
    (("" (expand append)
      (("" (expand append) (("" (propax) nil nil)) nil)) nil))
    nil)
   ((append def-decl "list[T]" list_props nil)) shostak))
 (length_duplicate 0
  (length_duplicate-1 nil 3728454660
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (expand "duplicate_elements" 1)
          (("2" (expand "length" 1)
            (("2" (expand "length" 1 1) (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T type-decl nil exam nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (duplicate_elements def-decl "list[T]" exam nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (null_reverse 0
  (null_reverse-1 nil 3728454923
   ("" (induct "l")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (split 1) (("1" (grind) nil nil) ("2" (propax) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((append def-decl "list[T]" list_props nil)
    (list_induction formula-decl nil list_adt nil)
    (T type-decl nil exam nil)
    (reverse def-decl "list[T]" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (null_append 0
  (null_append-1 nil 3728455132
   ("" (skeep)
    (("" (split)
      (("1" (case "null?(l1)")
        (("1" (case "null?(l2)")
          (("1" (assert) nil nil)
           ("2" (expand "append") (("2" (assert) nil nil)) nil))
          nil)
         ("2" (expand "append") (("2" (assert) nil nil)) nil))
        nil)
       ("2" (expand "append")
        (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((append def-decl "list[T]" list_props nil)
    (T type-decl nil exam nil) (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (length_append 0
  (length_append-1 nil 3728455370
   ("" (induct "l1")
    (("1" (grind) nil nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (skeep 1)
          (("2" (inst -1 l2)
            (("2" (expand append 1)
              (("2" (expand length 1 1)
                (("2" (expand length 1 2) (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T type-decl nil exam nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (append def-decl "list[T]" list_props nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (length_reverse 0
  (length_reverse-1 nil 3728455676
   ("" (induct "l")
    (("1" (expand reverse) (("1" (propax) nil nil)) nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (expand reverse 1)
          (("2" (lemma length_append)
            (("2" (inst? -1)
              (("2" (replace -1)
                (("2" (expand length 1 3)
                  (("2" (expand length 1 2)
                    (("2" (assert)
                      (("2" (expand length 1 2)
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil exam nil)
    (list_induction formula-decl nil list_adt nil)
    (T type-decl nil exam nil)
    (reverse def-decl "list[T]" list_props nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (append_assoc 0
  (append_assoc-1 nil 3728455912
   ("" (induct-and-simplify "l1") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (T type-decl nil exam nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (append_null 0
  (append_null-1 nil 3728455436
   ("" (induct "l")
    (("1" (assert)
      (("1" (expand "append") (("1" (propax) nil nil)) nil)) nil)
     ("2" (skolem 1 ("x" "l"))
      (("2" (flatten)
        (("2" (expand append 1)
          (("2" (replace -1) (("2" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((list_induction formula-decl nil list_adt nil)
    (T type-decl nil exam nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (reverse_append 0
  (reverse_append-1 nil 3728455976
   ("" (lemma append_assoc)
    (("" (lemma append_null) (("" (induct-and-simplify "l1") nil nil))
      nil))
    nil)
   ((append_null formula-decl nil exam nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (reverse def-decl "list[T]" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (T type-decl nil exam nil)
    (list_induction formula-decl nil list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append_assoc formula-decl nil exam nil))
   shostak))
 (reverse_reverse 0
  (reverse_reverse-1 nil 3728455512
   ("" (lemma reverse_append) (("" (induct-and-simplify "l") nil nil))
    nil)
   ((append def-decl "list[T]" list_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (T type-decl nil exam nil)
    (reverse def-decl "list[T]" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (reverse_append formula-decl nil exam nil))
   shostak)))

